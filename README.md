# Documentation
As there is no exact data given to us to calculate the search-volume, I believed that trying to make an educated guess was the best option. I realized that the Amazon search bar returned suggestions not only after the complete word is typed, but also after each typed letter. Popular keywords (e.g. iphone, apple etc.) popped up on these suggestions even when only a few letters of the brand were typed, therefore I decided to base my algorithm on this fact. The algorithm starts querying the Autocompletion API with each progressive substring of the given keyword (i.e. “i , “ip” , “iph” , “ipho” , “iphon”, “iphone” for the keyword “iphone”) as if a real customer would be typing it to the search bar. After each request, it scans the suggestions received from the API and counts any matching occurrences of the given keyword (“iphone” in this case) in these suggestions. After all substrings are scanned, it assigns a score to the keyword according to the ratio of the total number of matching occurrences to the total number of suggestions made for all substrings. (e.g. keyword "iphone" occured 57 times on 60 suggestions, hence score is 95)

As there are thousands of possible keywords stored in Amazon’s autocompletion database and we only see the top 10 results, I do believe that the hint is correct and the order of the top 10 is relatively insignificant. I believe that the algorithm is useful when comparing keywords starting with the same letter; but it lacks precision on other cases, as we can never know how many times the displayed suggestions are searched: the top 10 results for a string could have around 10k hits while a completely different brand name with a different initial could show suggestions with 100k hits. During my tests, I have observed that even the longest word in dictionary “pneumonoultramicroscopicsilicovolcanoconiosis” (45 letters) had a round trip smaller than 8 seconds, and because that most potential inputs (words or phrases) would be much shorter than this; I have added a 10 second timeout but only return an exception instead of handling the situation to prevent adding further complexity to the code. 
